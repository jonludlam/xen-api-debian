From f4b652715e1fc7a75ed68702ddf7a29301fca6fa Mon Sep 17 00:00:00 2001
From: David Scott <dave.scott@eu.citrix.com>
Date: Fri, 30 Sep 2011 16:35:14 +0100
Subject: [PATCH] Treat VIFs and VBD hotplug scripts differently: expect the
 /xapi/... convention for VIFs but the upstream
 hotplug-status=connected convention for VBDs

This satisfies the following constraints:
1. non-XCP blkback implementations (eg FreeBSD) use hotplug-status to signal completion (even if they don't use "hotplug" like linux does)
2. netback implementations will delete the hotplug-status key when a driver disconnects temporarily, and therefore this doesn't signal "hot unplug complete"

Hopefully after this commit xapi should work
1. in XCP as normal
2. in Kronos with a linux PVops dom0
3. with driver domains

Signed-off-by: David Scott <dave.scott@eu.citrix.com>
---
 ocaml/xenops/device.ml  |    4 +++-
 ocaml/xenops/hotplug.ml |   31 +++++++++++++++++++++++--------
 2 files changed, 26 insertions(+), 9 deletions(-)

diff --git a/ocaml/xenops/device.ml b/ocaml/xenops/device.ml
index 64c87b1..ecaeb80 100644
--- a/ocaml/xenops/device.ml
+++ b/ocaml/xenops/device.ml
@@ -147,7 +147,9 @@ let request_closure ~xs (x: device) =
 		)
 	)
 
-let unplug_watch ~xs (x: device) = Watch.map (fun () -> "") (Watch.key_to_disappear (Hotplug.status_node x))
+let unplug_watch ~xs (x: device) =
+	let path = Hotplug.path_written_by_hotplug_scripts x in
+	Watch.map (fun () -> "") (Watch.key_to_disappear path)
 let error_watch ~xs (x: device) = Watch.value_to_appear (error_path_of_device ~xs x)
 let frontend_closed ~xs (x: device) = Watch.map (fun () -> "") (Watch.value_to_become (frontend_path_of_device ~xs x ^ "/state") (Xenbus.string_of Xenbus.Closed))
 
diff --git a/ocaml/xenops/hotplug.ml b/ocaml/xenops/hotplug.ml
index 816854c..3725580 100644
--- a/ocaml/xenops/hotplug.ml
+++ b/ocaml/xenops/hotplug.ml
@@ -61,8 +61,22 @@ let get_private_data_path_of_device (x: device) =
 let get_hotplug_path (x: device) =
 	sprintf "%s/hotplug/%s/%d" (get_private_path x.frontend.domid) (string_of_kind x.backend.kind) x.backend.devid
 
-(* The path in xenstore written to by the hotplug scripts *)
-let status_node (x: device) = get_hotplug_path x ^ "/hotplug"
+let path_written_by_hotplug_scripts (x: device) = match x.backend.kind with
+	| Vif -> get_hotplug_path x ^ "/hotplug"
+	| Vbd ->
+		sprintf "/local/domain/%d/backend/%s/%d/%d/hotplug-status"
+			x.backend.domid (string_of_kind x.backend.kind) x.frontend.domid x.frontend.devid
+	| k -> failwith (Printf.sprintf "No xenstore interface for this kind of device: %s" (string_of_kind k))
+
+let value_written_by_hotplug_scripts (x: device) = match x.backend.kind with
+	| Vif -> "online"
+	| Vbd -> "connected"
+	| k -> failwith (Printf.sprintf "No xenstore interface for this kind of device: %s" (string_of_kind k))
+
+let hotplugged ~xs (x: device) =
+	let path = path_written_by_hotplug_scripts x
+	and v = value_written_by_hotplug_scripts x in
+	try xs.Xs.read path = v with Xb.Noent -> false
 
 (* The path in xenstore written to by the frontend hotplug scripts *)
 let frontend_status_node (x: device) = 
@@ -86,24 +100,24 @@ let blkback_error_node ~xs (x: device) =
    (ie not an API-initiated hotunplug; this is start of day) then we check the state 
    of the backend hotplug scripts. *)
 let device_is_online ~xs (x: device) = 
-  let backend_hotplug () = try xs.Xs.read (status_node x) = "online" with Xb.Noent -> false
-  and backend_shutdown () = try ignore(xs.Xs.read (backend_shutdown_done_path_of_device ~xs x)); true with Xb.Noent -> false 
+  let backend_shutdown () = try ignore(xs.Xs.read (backend_shutdown_done_path_of_device ~xs x)); true with Xb.Noent -> false 
   and backend_request () = try ignore(xs.Xs.read (backend_shutdown_request_path_of_device ~xs x)); true with Xb.Noent -> false in
 
   match x.backend.kind with
   | Pci | Vkbd | Vfb  -> assert false (* PCI backend doesn't create online node *)
-  | Vif -> backend_hotplug ()
+  | Vif -> hotplugged ~xs x
   | ( Vbd | Tap ) -> 
       if backend_request () 
       then not(backend_shutdown ())
-      else backend_hotplug ()
+      else hotplugged ~xs x
 
 let wait_for_plug ~xs (x: device) = 
   debug "Hotplug.wait_for_plug: %s" (string_of_device x);
   try
     Stats.time_this "udev backend add event" 
       (fun () ->
-    ignore(Watch.wait_for ~xs ~timeout:hotplug_timeout (Watch.value_to_appear (status_node x)));
+		  let path = path_written_by_hotplug_scripts x in
+		  ignore(Watch.wait_for ~xs ~timeout:hotplug_timeout (Watch.value_to_appear path));
       );
     debug "Synchronised ok with hotplug script: %s" (string_of_device x)
   with Watch.Timeout _ ->
@@ -114,7 +128,8 @@ let wait_for_unplug ~xs (x: device) =
   try
     Stats.time_this "udev backend remove event" 
       (fun () ->
-    ignore(Watch.wait_for ~xs ~timeout:hotplug_timeout (Watch.key_to_disappear (status_node x)));
+		  let path = path_written_by_hotplug_scripts x in
+		  ignore(Watch.wait_for ~xs ~timeout:hotplug_timeout (Watch.key_to_disappear path));
       );
     debug "Synchronised ok with hotplug script: %s" (string_of_device x)
   with Watch.Timeout _ ->
-- 
1.7.5.4

